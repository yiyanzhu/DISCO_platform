"""
VASP 服务模块
处理所有 VASP 特定的逻辑：参数模板、输入文件生成、结果解析
"""

import os
from typing import Dict, List, Tuple, Optional


class VaspConfigManager:
    """VASP 配置管理 - 负责参数模板和文件生成"""

    # INCAR 默认模板
    INCAR_TEMPLATE = """! VASP Calculation Configuration
! Generated by Auto-Workflow

! === General Settings ===
ENCUT = {encut}          ! Plane-wave cutoff energy (eV)
NSW = {nsw}              ! Number of ionic steps
IBRION = {ibrion}        ! Ionic relaxation (0=static, 2=CG)
POTIM = {potim}          ! Time step for ionic motion
EDIFF = {ediff}          ! Electronic convergence criterion
PREC = {prec}            ! Precision level (Low, Medium, High)

! === Electronic Structure ===
NELM = {nelm}            ! Max electronic iterations
NELMIN = {nelmin}        ! Min electronic iterations
ISMEAR = {ismear}        ! Smearing method (-5=tetrahedra)
SIGMA = {sigma}          ! Smearing width (eV)

! === Output ===
LWAVE = .FALSE.          ! Write WAVECAR
LCHARG = .FALSE.         ! Write CHGCAR
LVTOT = .FALSE.          ! Write total potential
"""

    # KPOINTS 默认模板（Gamma only）
    KPOINTS_TEMPLATE = """Automatic mesh
0
Gamma
{kmesh_x} {kmesh_y} {kmesh_z}
0 0 0
"""

    # SLURM 脚本默认模板
    SLURM_TEMPLATE = """#!/bin/bash
#SBATCH --job-name={job_name}
#SBATCH --nodes={n_nodes}
#SBATCH --ntasks-per-node={n_procs}
#SBATCH --time={time_limit}
#SBATCH --partition={partition}
{email_directive}
module load VASP/6.3.2-GPU 2>/dev/null || module load vasp 2>/dev/null || echo "VASP module not loaded"

export OMP_NUM_THREADS=1

echo "=== VASP Calculation Started at $(date) ===" >> vasp.log
mpirun -np {total_procs} {vasp_command} >> vasp.log 2>&1
EXIT_CODE=$?
echo "=== VASP Calculation Finished at $(date), Exit Code: $EXIT_CODE ===" >> vasp.log

exit $EXIT_CODE
"""

    def __init__(self, incar_path: Optional[str] = None, kpoints_path: Optional[str] = None, slurm_path: Optional[str] = None):
        """
        初始化 VASP 配置管理器
        优先从 services/vasp/templates/ 目录加载模板文件

        Args:
            incar_path: 自定义 INCAR 模板路径
            kpoints_path: 自定义 KPOINTS 模板路径
            slurm_path: 自定义 SLURM 脚本模板路径
        """
        base_dir = os.path.dirname(__file__)
        templates_dir = os.path.join(base_dir, "templates")

        # 1. INCAR
        if not incar_path:
            incar_path = os.path.join(templates_dir, "INCAR")
        
        if os.path.exists(incar_path):
            with open(incar_path, 'r', encoding='utf-8') as f:
                self.incar_template = f.read()
        else:
            self.incar_template = self.INCAR_TEMPLATE

        # 2. KPOINTS
        if not kpoints_path:
            kpoints_path = os.path.join(templates_dir, "KPOINTS")
            
        if os.path.exists(kpoints_path):
            with open(kpoints_path, 'r', encoding='utf-8') as f:
                self.kpoints_template = f.read()
        else:
            self.kpoints_template = self.KPOINTS_TEMPLATE

        # 3. SLURM
        if not slurm_path:
            slurm_path = os.path.join(templates_dir, "slurm.sh")
            
        if os.path.exists(slurm_path):
            with open(slurm_path, 'r', encoding='utf-8') as f:
                self.slurm_template = f.read()
        else:
            self.slurm_template = self.SLURM_TEMPLATE

    def generate_incar(self, params: Dict[str, any]) -> str:
        """
        生成 INCAR 文件内容

        Args:
            params: 参数字典，例如 {
                'encut': 500,
                'nsw': 100,
                'ibrion': 2,
                'potim': 0.5,
                'ediff': 1e-5,
                'prec': 'High',
                'nelm': 100,
                'nelmin': 4,
                'ismear': 0,
                'sigma': 0.05
            }

        Returns:
            INCAR 文件内容
        """
        content = self.incar_template
        for key, value in params.items():
            content = content.replace(f"{{{key}}}", str(value))
        return content

    def generate_kpoints(self, kmesh: Tuple[int, int, int] = (4, 4, 4)) -> str:
        """
        生成 KPOINTS 文件内容

        Args:
            kmesh: k-point mesh (kx, ky, kz)

        Returns:
            KPOINTS 文件内容
        """
        content = self.kpoints_template
        content = content.replace("{kmesh_x}", str(kmesh[0]))
        content = content.replace("{kmesh_y}", str(kmesh[1]))
        content = content.replace("{kmesh_z}", str(kmesh[2]))
        return content

    def generate_slurm_script(
        self,
        job_name: str = "VASP_Job",
        n_nodes: int = 1,
        n_procs: int = 16,
        time_limit: str = "00:30:00",
        partition: str = "gpu",
        email: Optional[str] = None,
        vasp_command: str = "vasp_std"
    ) -> str:
        """
        生成 SLURM 脚本内容

        Args:
            job_name: 任务名称
            n_nodes: 计算节点数
            n_procs: 每个节点的进程数
            time_limit: 计算时间限制
            partition: 分区名称
            email: 通知邮箱
            vasp_command: VASP执行命令

        Returns:
            SLURM脚本内容
        """
        content = self.slurm_template
        total_procs = n_nodes * n_procs
        
        # 构建邮箱指令
        email_directive = ""
        if email:
            email_directive = f"#SBATCH --mail-type=END,FAIL\n#SBATCH --mail-user={email}"
        
        # 替换模板占位符
        content = content.replace("{job_name}", job_name)
        content = content.replace("{n_nodes}", str(n_nodes))
        content = content.replace("{n_procs}", str(n_procs))
        content = content.replace("{time_limit}", time_limit)
        content = content.replace("{partition}", partition)
        content = content.replace("{email_directive}", email_directive)
        content = content.replace("{total_procs}", str(total_procs))
        content = content.replace("{vasp_command}", vasp_command)
        
        return content


class VaspInputFileGenerator:
    """VASP 输入文件生成器"""

    @staticmethod
    def generate_poscar(structure_dict: Dict, comment: str = "VASP Structure") -> str:
        """
        从 pymatgen Structure.as_dict() 生成 POSCAR 内容

        Args:
            structure_dict: pymatgen Structure.as_dict() 的结果
            comment: POSCAR 注释行

        Returns:
            POSCAR 文件内容
        """
        # 这个函数需要 pymatgen，由调用者实现或导入
        # 这里仅提供框架
        try:
            from pymatgen.core import Structure
            from pymatgen.io.vasp import Poscar

            struct = Structure.from_dict(structure_dict)
            poscar = Poscar(struct)
            return str(poscar)
        except Exception as e:
            raise ValueError(f"生成 POSCAR 失败: {e}")

    @staticmethod
    def generate_potcar_list(element_list: List[str]) -> List[str]:
        """
        生成 POTCAR 元素列表（用户需手动检查和准备真实 POTCAR）

        Args:
            element_list: 元素符号列表

        Returns:
            POTCAR 需求列表
        """
        return list(set(element_list))


class VaspResultParser:
    """VASP 计算结果解析器"""

    @staticmethod
    def parse_oszicar(content: str) -> Tuple[bool, Dict]:
        """
        解析 OSZICAR 文件（能量收敛信息）

        Args:
            content: OSZICAR 文件内容

        Returns:
            (成功标志, 解析结果字典)
        """
        result = {
            'converged': False,
            'ionic_steps': 0,
            'final_energy': None,
            'initial_energy': None,
            'energies': [],
            'forces': [],
            'magnetic_moments': []
        }

        try:
            lines = content.strip().split('\n')
            for line_idx, line in enumerate(lines):
                parts = line.split()
                if len(parts) >= 5:
                    try:
                        # OSZICAR 格式: TAU   Etot   E0   E-e  E1   E2-Ekin   E3-EAT
                        # 通常第5列是Etot (总能量)
                        energy = float(parts[4])
                        result['energies'].append(energy)
                        
                        # 如果有力的信息 (通常在第6列左右)
                        if len(parts) >= 6:
                            try:
                                force = float(parts[5])
                                result['forces'].append(force)
                            except:
                                pass
                        
                        # 如果有磁矩 (通常在最后)
                        if len(parts) >= 7:
                            try:
                                mag = float(parts[-1])
                                result['magnetic_moments'].append(mag)
                            except:
                                pass
                    except:
                        continue

            if result['energies']:
                result['initial_energy'] = result['energies'][0]
                result['final_energy'] = result['energies'][-1]
                result['ionic_steps'] = len(result['energies'])
                result['converged'] = True
                
                # 计算能量变化
                result['energy_difference'] = result['final_energy'] - result['initial_energy']
                result['energy_per_atom'] = result['final_energy']  # 简化，实际需要原子数

            return True, result
        except Exception as e:
            return False, {'error': str(e)}

    @staticmethod
    def parse_outcar(content: str) -> Dict:
        """
        解析 OUTCAR 文件（关键计算信息）

        Args:
            content: OUTCAR 文件内容

        Returns:
            解析结果字典
        """
        result = {
            'raw': content[:2000],  # 保存前 2000 字符
            'converged': 'reached required accuracy' in content.lower(),
            'electronic_steps': 0,
            'ionic_steps': 0,
            'job_finished': 'Total CPU time' in content,
            'cpu_time': None,
            'elapsed_time': None,
            'max_force': None,
            'pressure': None,
            'volume': None,
            'warnings': []
        }

        # 计算电子步数
        e_count = content.count('Iteration')
        if e_count > 0:
            result['electronic_steps'] = e_count

        # 计算离子步数
        ionic_count = content.count('POSITION')
        if ionic_count > 0:
            result['ionic_steps'] = ionic_count

        # 提取 CPU 时间
        import re
        cpu_match = re.search(r'Total CPU time used \(sec\):\s+([0-9.]+)', content)
        if cpu_match:
            result['cpu_time'] = float(cpu_match.group(1))
        
        elapsed_match = re.search(r'Elapsed time \(sec\):\s+([0-9.]+)', content)
        if elapsed_match:
            result['elapsed_time'] = float(elapsed_match.group(1))
        
        # 提取最大力
        force_match = re.search(r'Max-Force\s*=\s*([0-9.E+-]+)', content)
        if force_match:
            result['max_force'] = float(force_match.group(1))
        
        # 提取压力
        pressure_match = re.search(r'external pressure\s*=\s*([0-9.E+-]+)\s*kB', content)
        if pressure_match:
            result['pressure'] = float(pressure_match.group(1))
        
        # 提取体积
        volume_match = re.search(r'Volume of cell\s*:\s*([0-9.]+)', content)
        if volume_match:
            result['volume'] = float(volume_match.group(1))
        
        # 检查警告信息
        if 'ERROR' in content or 'error' in content:
            result['warnings'].append('计算中发现错误')
        if 'VERY BAD NEWS!' in content:
            result['warnings'].append('收敛问题严重')
        if 'POTCAR' in content and 'could not' in content.lower():
            result['warnings'].append('POTCAR相关问题')

        return result
