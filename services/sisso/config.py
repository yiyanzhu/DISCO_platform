"""
SISSO 服务模块
处理所有 SISSO 特定的逻辑：参数模板、输入文件生成、结果解析
"""

import re
import os
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import pandas as pd
from services.common.templates import load_slurm_template
from services.config.loader import load_config, get_queue_defaults


class SissoConfigManager:
    """SISSO 配置管理 - 负责参数模板和文件生成"""

    _GLOBAL_CFG = load_config()
    _QUEUE_DEFAULTS = get_queue_defaults(_GLOBAL_CFG)

    # 默认 SISSO.in 模板
    DEFAULT_TEMPLATE = """! SISSO Descriptor Identification Configuration
! Generated by Auto-Workflow

ptype=1                ! Property type: 1=regression, 2=classification
ntask=1                ! Multi-task learning (if >1)
desc_dim={desc_dim}    ! Descriptor dimension
nsample={nsample}      ! Number of training samples
restart=0              ! 0=start from scratch, 1=continue

! ===== Feature Construction & SIS =====
fstore=1               ! 1=by data (fast), 2=by expression (memory-efficient)
nsf={nsf}              ! Number of scalar features
ops='{ops}'            ! Operators: (+)(-)(*)(/)(exp)(log)(^2)(sqrt)(sin)(cos)
fcomplexity={fcomplexity}  ! Max feature complexity
funit=(1:{nsf})        ! All features have same unit
fmax_min=1e-3          ! Discard if max(|feature|) < this
fmax_max=1e5           ! Discard if max(|feature|) > this
nf_sis=50000           ! Max features in SIS subspace

! ===== Sparse Regression =====
method_so='L0'         ! L0 or L1L0
fit_intercept=.true.   ! Fit intercept
nmodel={nmodel}        ! Number of top models to output
"""

    # 默认 SLURM 脚本模板（首选共享模板，回退内置文本）
    try:
        _LOCAL_SLURM = Path(__file__).resolve().parent / "templates" / "slurm.sh"
        SLURM_TEMPLATE = load_slurm_template(path=_LOCAL_SLURM)
    except Exception:
        SLURM_TEMPLATE = """#!/bin/bash
#SBATCH --job-name={job_name}
#SBATCH --nodes={n_nodes}
#SBATCH --ntasks-per-node={n_procs}
#SBATCH --time={time_limit}
#SBATCH --partition={partition}
{email_directive}
module load SISSO 2>/dev/null || echo "SISSO module not loaded"

export OMP_NUM_THREADS={omp_threads}

echo "=== SISSO Feature Selection Started at $(date) ===" >> sisso.log
mpirun -np {total_procs} sisso >> sisso.log 2>&1
EXIT_CODE=$?
echo "=== SISSO Feature Selection Finished at $(date), Exit Code: $EXIT_CODE ===" >> sisso.log

exit $EXIT_CODE
"""

    def __init__(self, template_path: Optional[str] = None, slurm_path: Optional[str] = None):
        """
        初始化 SISSO 配置管理器

        Args:
            template_path: 自定义模板文件路径（可选）
            slurm_path: 自定义 SLURM 脚本模板路径（可选）
        """
        if template_path and os.path.exists(template_path):
            with open(template_path, 'r', encoding='utf-8') as f:
                self.base_template = f.read()
        else:
            self.base_template = self.DEFAULT_TEMPLATE

        if slurm_path and os.path.exists(slurm_path):
            with open(slurm_path, 'r', encoding='utf-8') as f:
                self.slurm_template = f.read()
        else:
            self.slurm_template = self.SLURM_TEMPLATE

    def update_template(self, params: Dict[str, any]) -> str:
        """
        使用参数更新模板

        Args:
            params: 参数字典，例如 {
                'desc_dim': 2,
                'nsample': 100,
                'nsf': 10,
                'fcomplexity': 3,
                'ops': '(+)(-)(*)(/)',
                'nmodel': 100
            }

        Returns:
            更新后的配置内容
        """
        content = self.base_template

        for key, value in params.items():
            # 使用 .format() 风格替换
            content = content.replace(f"{{{key}}}", str(value))

        return content

    def generate_slurm_script(
        self,
        job_name: str = "SISSO_Job",
        n_nodes: int = 1,
        n_procs: int = 16,
        omp_threads: int = 1,
        time_limit: str = "01:00:00",
        partition: str = "gpu",
        email: Optional[str] = None
    ) -> str:
        """
        生成 SLURM 脚本内容

        Args:
            job_name: 任务名称
            n_nodes: 计算节点数
            n_procs: 每个节点的进程数
            omp_threads: OpenMP 线程数
            time_limit: 计算时间限制
            partition: 分区名称
            email: 通知邮箱

        Returns:
            SLURM脚本内容
        """
        total_procs = n_nodes * n_procs

        # 构建邮箱指令
        email_directive = ""
        if email:
            email_directive = f"#SBATCH --mail-type=END,FAIL\n#SBATCH --mail-user={email}"

        command_lines = [
            "module load SISSO 2>/dev/null || echo \"SISSO module not loaded\"",
            f"export OMP_NUM_THREADS={omp_threads}",
            "echo \"=== SISSO Feature Selection Started at $(date) ===\" >> sisso.log",
            f"mpirun -np {total_procs} sisso >> sisso.log 2>&1",
            "EXIT_CODE=$?",
            "echo \"=== SISSO Feature Selection Finished at $(date), Exit Code: $EXIT_CODE ===\" >> sisso.log",
            "exit $EXIT_CODE",
        ]

        fmt = {
            "job_name": job_name,
            "n_nodes": n_nodes or self._QUEUE_DEFAULTS.get("nodes", 1),
            "n_procs": n_procs or self._QUEUE_DEFAULTS.get("ntasks_per_node", 16),
            "ntasks": n_procs or self._QUEUE_DEFAULTS.get("ntasks_per_node", 16),
            "ntasks_per_node": n_procs or self._QUEUE_DEFAULTS.get("ntasks_per_node", 16),
            "omp_threads": omp_threads,
            "time_limit": time_limit or self._QUEUE_DEFAULTS.get("time_limit", "01:00:00"),
            "partition": partition or self._QUEUE_DEFAULTS.get("partition", "gpu"),
            "email_directive": email_directive,
            "total_procs": total_procs,
            "command": "\n".join(command_lines),
        }

        try:
            return self.slurm_template.format(**fmt)
        except KeyError:
            # 回退简单占位替换以兼容旧模板
            content = self.slurm_template
            for k, v in fmt.items():
                content = content.replace(f"{{{k}}}", str(v))
            return content

    def update_template_regex(self, content: str, params: Dict[str, any]) -> str:
        """
        使用正则表达式修改参数（支持现有 SISSO.in）

        Args:
            content: 原始配置文本
            params: 参数字典

        Returns:
            修改后的配置文本
        """
        result = content
        for key, value in params.items():
            # 匹配 key=value 模式，忽略大小写，支持注释
            pattern = re.compile(
                fr"^(\s*{key}\s*=\s*)([^!\n]*)",
                re.IGNORECASE | re.MULTILINE
            )
            if pattern.search(result):
                result = pattern.sub(fr"\g<1>{value}", result)
            else:
                # 如果找不到 key，追加到末尾
                result += f"\n{key}={value}\n"

        return result


class SissoTrainDataBuilder:
    """SISSO 训练数据文件生成器"""

    def __init__(self, elements_df: pd.DataFrame):
        """
        初始化训练数据生成器

        Args:
            elements_df: 元素属性数据框
        """
        self.elements_df = elements_df

    def get_atomic_features(
        self,
        element_symbol: str,
        selected_columns: Optional[List[str]] = None
    ) -> List[float]:
        """
        查询元素属性特征

        Args:
            element_symbol: 元素符号
            selected_columns: 选定的列名（None 则自动选择数值列）

        Returns:
            特征值列表
        """
        row = self.elements_df[self.elements_df['symbol'].str.strip() == element_symbol.strip()]
        if row.empty:
            return []

        if not selected_columns:
            # 自动选择数值列
            cols = row.select_dtypes(include=['number']).columns.tolist()
            vals = row[cols].values.flatten().tolist()
        else:
            vals = row[selected_columns].values.flatten().tolist()

        # 处理 NaN 值
        return [0 if pd.isna(v) else v for v in vals]

    def build_train_dat(
        self,
        structures: List[Dict],
        targets: Dict[str, float],
        atom_indices: List[int],
        selected_columns: Optional[List[str]] = None,
        parse_structure_func=None
    ) -> Tuple[str, int, int]:
        """
        生成 train.dat 文件

        Args:
            structures: 结构数据列表 [{'filename': str, 'content': str}, ...]
            targets: 目标值字典 {filename_key: value}
            atom_indices: 用于特征的原子索引
            selected_columns: 选定的原子属性列
            parse_structure_func: 解析结构的函数

        Returns:
            (train.dat 内容, 有效样本数, 特征维度)
        """
        if parse_structure_func is None:
            raise ValueError("必须提供 parse_structure_func 函数")

        feature_names = []
        try:
            # 从第一个结构获取特征名
            s0 = parse_structure_func(structures[0]['content'])
            for idx in atom_indices:
                el = s0[idx].specie.symbol
                row = self.elements_df[self.elements_df['symbol'].str.strip() == el.strip()]
                if row.empty:
                    continue

                if selected_columns:
                    cols = selected_columns
                else:
                    cols = row.select_dtypes(include=['number']).columns.tolist()

                feature_names.extend([f"Atom{idx}_{c}" for c in cols])
        except Exception as e:
            raise ValueError(f"特征名生成失败: {e}")

        if not feature_names:
            raise ValueError("无法生成特征名")

        # 构建 train.dat 内容
        train_lines = ["Property " + " ".join(feature_names)]
        valid_count = 0

        for s in structures:
            fname = s['filename']
            # 尝试多种 key 匹配方式
            key = os.path.splitext(fname)[0]
            val = targets.get(fname) or targets.get(key)

            if val is not None:
                try:
                    struct = parse_structure_func(s['content'])
                    feats = []
                    for idx in atom_indices:
                        el = struct[idx].specie.symbol
                        feats.extend(self.get_atomic_features(el, selected_columns))

                    if feats:
                        train_lines.append(f"{val} " + " ".join(map(str, feats)))
                        valid_count += 1
                except Exception as e:
                    print(f"警告: 处理 {fname} 失败: {e}")
                    continue

        if valid_count == 0:
            raise ValueError("没有有效样本（ID 可能不匹配）")

        train_dat_content = "\n".join(train_lines)
        return train_dat_content, valid_count, len(feature_names)


class SissoResultParser:
    """SISSO 输出结果解析器"""

    @staticmethod
    def parse_sisso_out(content: str) -> Dict:
        """
        解析 SISSO.out 文件

        Args:
            content: SISSO.out 文件内容

        Returns:
            解析结果字典
        """
        result = {
            'raw': content,
            'completed': False,
            'best_model': None,
            'models': [],
            'errors': []
        }

        # 简单启发式判断
        if 'successfully' in content.lower() or 'best' in content.lower():
            result['completed'] = True

        # 提取模型信息（简单示例）
        model_pattern = r"Model\s*(\d+).*?RMSE:\s*([0-9.e\-]+)"
        matches = re.findall(model_pattern, content, re.IGNORECASE)
        result['models'] = [
            {'rank': int(m[0]), 'rmse': float(m[1])}
            for m in matches
        ]

        if result['models']:
            result['best_model'] = result['models'][0]

        return result
